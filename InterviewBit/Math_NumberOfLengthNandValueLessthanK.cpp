/*
Let us try to solve for all the possible cases.
Let d be size of A.

Case 1: If B is greater than length of C or d is 0 then no such number is possible.

Case 2: If B is smaller than length of C then all the possible combination of digits of length B are valid.

Generate all such B digit numbers.
For the first position we can’t have 0 and for ther rest of (B - 1) position we can have all d possible digits.
Hence, Answer = d B if A contains 0 else (d-1) * ( d )(B-1)

Case 3: If B is equal to length of C
Construct digit array of C ( call it as digit[]).

Let First(i) be a number formed by taking first i digits of it.
Let lower[i] denote number of elements in A which are smaller than i.
It can be easily computed by idea similar to prefix sum.
For example:

First(2) of 423 is 42.
If  A =  [ 0, 2] then lower[0] = 0, lower[0] = 0, lower[1]  = 1,  lower[2] = 1, lower[3] = 2
Generate B digit numbers by dynamic programming. Let say dp[i] denotes the total numbers of length i which are less than first i digits of C.

Elements in dp[i] can be generated by two cases :

i. For all the Numbers whose First(i - 1) is less than First (i-1) of C, we can put any digit at i’th index.
Hence, dp[i] += (dp[i-1] * d)

ii. For all the Numbers whose First (i - 1) is same as First (i - 1) of C, we can only put those digits which are smaller than digit[i] .

Hence , dp[i] += lower[digit[i]]

Final answer will be dp[B]

Remark:
For first index don’t include 0 if B is not 1 and dp[0] will be 0.

Time Complexity = O(B)
*/

vector <int> numToVec(int N) {
	vector<int> digit;
	while (N != 0) {
		digit.push_back(N % 10);
		N = N / 10;
	}
	if (digit.size() == 0)
		digit.push_back(0);

	reverse(digit.begin(), digit.end());
	return digit;
}

int Solution:: solve(vector<int> &A, int B, int C) {
	vector<int> digit;
	int  d, d2;
	// Convert number to digit array
	digit = numToVec(C);
	d = A.size();

	//Case 1
	if (B > digit.size()  || d == 0)
		return 0;

	// Case 2
	else if (B < digit.size()) {
		// contain 0
		if (A[0] == 0 && B != 1)
			return (d - 1) * pow(d, B - 1);
		else
			return pow(d, B);
	}

	//Case 3
	else {
		int dp[B + 1], lower[11];
		for (int i = 0; i <= B; i++)
			dp[i] = 0;
		for (int i = 0; i <= 10; i++)
			lower[i] = 0;
		for (int i = 0; i < d; i++)
			lower[A[i] + 1] = 1;

		for (int i = 1; i <= 10; i++)
			lower[i] = lower[i - 1] + lower[i];

		bool flag = true;
		dp[0] = 0;
		for (int i = 1; i <= B; i++) {
			d2 = lower[digit[i - 1]];
			dp[i] = dp[i - 1] * d;

			// For first index we can't use 0
			if (i == 1 &&  A[0] == 0 && B != 1)
				d2 = d2 - 1;

			//Whether (i-1) digit of generated number can be equal to (i - 1) digit of C.
			if (flag)
				dp[i] += d2;
			//Is digit[i - 1] present in A ?
			flag = flag & (lower[digit[i - 1] + 1] == lower[digit[i - 1]] + 1);
		}
		return dp[B];
	}
}